#pragma kernel Main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

struct GrassBlade
{
    float3 position;
    float rotAngle;
    float hash;
    float height;
    float width;
    float tilt;
    float bend;
    float3 surfaceNorm;
    float windForce;
    float sideBend;
};

struct ClumpParameters
{
    float pullToCentre;
    float pointInSameDirection;
    float baseHeight;
    float heightRandom;
    float baseWidth;
    float widthRandom;
    float baseTilt;
    float tiltRandom;
    float baseBend;
    float bendRandom;
};

StructuredBuffer<ClumpParameters> _ClumpParameters; // 草丛参数结构体缓冲区
AppendStructuredBuffer<GrassBlade> _GrassBlades; // 动态追加的草叶结构缓冲区
// AppendStructuredBuffer 和 StructuredBuffer 用于CPU和GPU之间的交互，允许在GPU计算着色器中动态添加草叶和获取草丛参数

uint _ResolutionX;
uint _ResolutionY;
float _GrassSpacing; // 草叶间距
float _JitterStrength; // 草叶随机强度

// Terrain parameters
Texture2D<float4> _HeightMap;
Texture2D<float4> _DetailMap;
SamplerState LinearClampSampler;

float3 _TerrainPosition;
float _HeightMapScale;
float _HeightMapMultiplier;

// Tile parameters
float3 _TilePosition;

// Camera Culling parameters => 根据距离和视锥体剔除草叶
float3 _WSpaceCameraPos;
float _DistanceCullStartDist;
float _DistanceCullEndDist;
float _DistanceCullMinimumGrassAmount; // 0-1范围内的密度比例值 使得草不会产生突兀的消失

// Camera Culling parameters => 根据视锥体剔除草叶
float4x4 _VP_MATRIX; // View Projection Matrix
float _FrustumCullNearOffset; // 视锥体近裁剪平面偏移
float _FrustumCullEdgeOffset; // 视锥体左右边缘偏移

// Clump parameters
float _ClumpScale;
Texture2D<float4> ClumpTex;
SamplerState samplerClumpTex;
float _NumClumpParameters; // 最大草丛数量

// Wind
Texture2D<float4> _LocalWindTex;
SamplerState LinearRepeatSampler;
float _LocalWindScale;
float _LocalWindSpeed;
float _LocalWindStrength;
float _LocalWindRotateAmount;
float _Time;
float2 _LocalWindDirection; // 风的方向

// 随机草叶位置生成函数 传入草叶坐标 返回一个伪随机值(0-1之间)
float2 HashFloat2(float2 p)
{
    float t = dot(p, float2(12.9898, 78.233));
    float2 q = float2(t, t * 1.61803398875);
    return frac(sin(q) * 43758.5453);
}

float Rand(float3 vec)
{
    return frac(sin(dot(vec.xyz, float3(12.9898, 78.233, 53.539))) * 43758.5453);
}

float Remap(float t)
{
    return (t * 2) - 1;
}

// 获取uv坐标处的高度值
float SampleHeight(float2 normalizedPos)
{
    float height = UnpackHeightmap(_HeightMap.SampleLevel(LinearClampSampler, normalizedPos, 0)); // 从高度图中采样高度值
    return height * _HeightMapMultiplier * 2;
}

float3 FitTerrainPosition(float3 position)
{
    float2 normalizedPos = (position.xz - _TerrainPosition.xz) / _HeightMapScale;
    return float3(position.x, _TerrainPosition.y + SampleHeight(normalizedPos), position.z);
}

// 获取uv坐标处的草叶的图层值 
float SampleGrass(float2 normalizedPos)
{
    float value = _DetailMap.SampleLevel(LinearClampSampler, normalizedPos, 0).r; // 取第一个通道的值(r)作为草叶图层值
    return value;
}

// 距离剔除函数 根据距离和一个0-1内的随机值判断是否保留草叶
uint DistanceCull(float3 worldPos, float hash)
{
    float d = distance(worldPos, _WSpaceCameraPos);
    float distanceSmoothStep = 1 - smoothstep(_DistanceCullStartDist, _DistanceCullEndDist, d);
    distanceSmoothStep = (distanceSmoothStep * (1 - _DistanceCullMinimumGrassAmount))
        + _DistanceCullMinimumGrassAmount; // 从 1-0 的数值变换到 1-{最小草叶密度}
    return hash > 1 - distanceSmoothStep ? 1 : 0;
}

// 视锥体剔除函数 根据视锥体矩阵判断草叶是否在视锥体内
uint FrustumCull(float3 worldPos)
{
    float4 clipPos = mul(_VP_MATRIX, float4(worldPos, 1)); // 将世界坐标转换为裁剪空间坐标

    // 注意：unity默认采用反向z(-z)来表示深度
    return (clipPos.z > clipPos.w // 比近裁剪面还近
               || clipPos.z < 0 // 比远裁剪面还远
               || clipPos.x < -clipPos.w + _FrustumCullEdgeOffset
               || clipPos.x > clipPos.w - _FrustumCullEdgeOffset
               || clipPos.y < -clipPos.w + _FrustumCullNearOffset
               || clipPos.y > clipPos.w)
               ? 0
               : 1;
}

[numthreads(8, 8, 1)] // 每个线程组8x8个线程
void Main(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _ResolutionX && id.y < _ResolutionY)
    {
        float3 position = float3(id.x, 0, id.y) * _GrassSpacing; // 将线程ID转换为草叶位置（网格行列号）
        float2 hash = HashFloat2(id.xy); // 计算位置的随机值
        float2 jitter = ((hash * 2) - 1) * _JitterStrength; // 生成抖动值
        position.xz += jitter; // 将抖动值应用到草叶位置
        position.xz += (_TilePosition.xz - _TerrainPosition.xz); // 计算Tile相对于Terrain的偏移

        float2 clumpUV = position.xz * float2(_ClumpScale.xx);
        float3 clumpData = ClumpTex.SampleLevel(samplerClumpTex, clumpUV, 0).xyz; // 采样Clump纹理

        float clumpParamsIndex = clumpData.x;
        clumpParamsIndex = clamp(clumpParamsIndex, 0, _NumClumpParameters - 1); // 限制草丛参数索引在有效范围内
        ClumpParameters bladeParameters = _ClumpParameters[int((clumpParamsIndex))];

        float2 clumpCentre = (clumpData.yz + floor(clumpUV)) / float2(_ClumpScale.xx); // 计算草丛中心位置
        position.xz = lerp(position.xz, clumpCentre, bladeParameters.pullToCentre); // 将草叶位置拉向草丛中心
        position.xz += _TerrainPosition.xz; // 将草叶位置可以跟随地形位置

        float2 normalizedPos = (position.xz - _TerrainPosition.xz) / _HeightMapScale;
        if (SampleGrass(normalizedPos) >= 0.7) return; // 如果草叶图层值大于0.5，则不生成草叶

        position.y = _TerrainPosition.y + SampleHeight(normalizedPos); // 根据高度图采样高度值并设置草叶的y坐标

        // Culling
        uint distanceCull = DistanceCull(position, hash.x);
        uint frustumCull = FrustumCull(position);

        if (distanceCull == 1 && frustumCull == 1)
        {
            GrassBlade blade;
            blade.position = position;

            float2 clumpHash = HashFloat2(clumpCentre);
            float2 sharedClumpFacing = normalize(tan((clumpHash + float2(0.13, 1.111)) * 2 - 1));
            float2 bladeFacing = normalize(HashFloat2(id.xy) * 2 - 1);
            bladeFacing = normalize(lerp(bladeFacing, sharedClumpFacing, bladeParameters.pointInSameDirection));
            float combinedFacingAngle = atan2(bladeFacing.y, bladeFacing.x);

            //wind
            float2 worldUV = position.xz;
            float2 localWindUV = worldUV * _LocalWindScale;

            //localWindUV += _Time * float2(1, 0.7) * _LocalWindSpeed; // 加上 速度 * 时间 得到采样风的uv
            localWindUV += _Time * normalize(_LocalWindDirection) * _LocalWindSpeed;

            // 只采样r通道作为风的强度
            float localWind = _LocalWindTex.SampleLevel(LinearRepeatSampler, localWindUV, 0).r;

            // 如果风从草叶的侧面吹过来，对草叶的旋转影响比较大，如果从正面吹过来，对草叶的旋转就会很小
            float localTheta = ((localWind * 2) - 1) * 3.14159; // 得到风的旋转弧度
            float2 localWindDir = float2(cos(localTheta), sin(localTheta));
            float2 grassSideVec = normalize(float2(-bladeFacing.y, bladeFacing.x));
            float rotateBladeFromLocalWindAmount = dot(grassSideVec, localWindDir);
            float localWindRotateAngle = rotateBladeFromLocalWindAmount * (3.14159 / 2) * _LocalWindRotateAmount;
            combinedFacingAngle += localWindRotateAngle;

            blade.rotAngle = combinedFacingAngle;
            blade.hash = Rand(id.xyx);
            blade.height = bladeParameters.baseHeight + Remap(Rand(id.xxy)) * bladeParameters.heightRandom;
            blade.width = bladeParameters.baseWidth + Remap(Rand(id.yxx)) * bladeParameters.widthRandom;
            blade.tilt = bladeParameters.baseTilt + Remap(Rand(id.xyx * float3(1.12, 3.3, 17.6))) * bladeParameters.
                tiltRandom;
            blade.bend = bladeParameters.baseBend + Remap(Rand(id.xyy * float3(12.32, 0.23, 3.39))) * bladeParameters.
                bendRandom;

            blade.bend += localWind * _LocalWindStrength; // wind bend

            float3 bitangent = float3(1, 0, 0);
            float3 tangent = float3(0, 0, 1);
            float3 vertexBitangent = FitTerrainPosition(position + bitangent * 0.01);
            float3 vertexTangent = FitTerrainPosition(position + tangent * 0.01);
            float3 newBitangent = (vertexBitangent - position).xyz;
            float3 newTangent = (vertexTangent - position).xyz;
            float3 norm = normalize(cross(newTangent, newBitangent));
            blade.surfaceNorm = norm;

            float3 posToCam = normalize(_WSpaceCameraPos - position);
            float viewAlignment = abs(dot(bladeFacing, normalize(posToCam.xz)));
            blade.sideBend = smoothstep(0.3, 0, viewAlignment) * 1.5;
            blade.windForce = localWind * _LocalWindStrength; // wind force

            _GrassBlades.Append(blade); // 将草叶添加到缓冲区
        }
    }
}
